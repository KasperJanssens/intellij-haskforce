/*
 * Use Command + Shift + G to generate parser in gen/ directory.
 * Then generate the lexer using Tools > Generate JFlex Lexer, then use Command + Shift + G on the lexer.
 * Be sure to add the gen/ directory to your sources.
 * In Intellij, right-click the gen directory and choose Mark Directory As > Sources.
 */

{
  parserClass="com.haskforce.parser.HaskellParser"
  parserUtilClass="org.intellij.grammar.parser.GeneratedParserUtilBase"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Haskell"
  psiImplClassSuffix="Impl"
  psiPackage="com.haskforce.psi"
  psiImplPackage="com.haskforce.psi.impl"

  elementTypeHolderClass="com.haskforce.psi.HaskellTypes"
  elementTypeClass="com.haskforce.psi.HaskellElementType"
  tokenTypeClass="com.haskforce.psi.HaskellTokenType"

  psiImplUtilClass="com.haskforce.psi.impl.HaskellPsiImplUtil"

  tokens=[
    lparen='('
    rparen=')'
    pipe='|'
    comma=','
    semicolon=';'
    lbracket='['
    rbracket=']'
    backtick='`'
    lbrace='{'
    rbrace='}'
    //return="\n"
    //linefeed="\r"
    //formfeed="\f"
    //vertab="\v"
    //tab="\t"
    //space=' '
    comment='regexp:--[^\r\n]*'
    dashes='regexp:--(-)*'
    opencom='{-'
    closecom='-}'
    doublequote='regexp:"'
    singlequote="'"
    //underscore='_'
    //ascSmall='regexp:[a-z]'
    //ascLarge='regexp:[A-Z]'
    exlamation='!'
    hash='#'
    dollar='$'
    percent='%'
    ampersand='&'
    asterisk='*'
    plus='+'
    period='.'
    slash='/'
    lessthan='<'
    equals='='
    greaterthan='>'
    question='?'
    ampersat='@'
    backslash='\'
    caret='^'
    minus='-'
    tilde='~'
    colon=':'
    digit='regexp:[0-9]'
    //hexit='regexp:[0-9a-fA-F]'
    //octit='regexp:[0-7]'
    octalEscape='regexp:o[0-7][0-7]*'
    hexadecimalEscape='regexp:x[0-9a-fA-F][0-9a-fA-F]*'
    /*doubleperiod='..'
    doublecolon='::'
    leftarrow='<-'
    rightarrow='->'
    doublearrow='=>'*/
    octalLiteral='regexp:0(o|O)[0-7]+'
    hexadecimalLiteral='regexp:0(x|X)[0-9a-fA-F]+'
    nullCharacter='\&'
    classtoken='class'
    charesc="regexp:[\a\b\f\n\r\t\v\\\"\|'&]"
    exponentPrefix='regexp:(e|E)(\+|\-)?'
    varidRegexp="regexp:[a-z_][a-zA-Z_0-9']*"
    conid="regexp:[A-Z][a-zA-Z_0-9']*"
    symbol="regexp:[!#$%&*+./<=>?@'\^\|\-~:]"
    graphic="regexp:[a-zA-Z0-9\"'!#$%&*+./<=>?@'\^\|\-~:(),;\[\]`{}]"
    whitechar="regexp:[\r\n\v\t]"
    //reservedopWithoutCons="regexp:(\.\.|::|=|\\|\||<-|->|@|~|=>)"
    //reservedop="regexp:(:|\.\.|::|=|\\|\||<-|->|@|~|=>)"
  ]
}

// Haskell 2010 Report - http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-140002

program ::= { lexeme | whitespace } *
private lexeme ::= qvarid | qconid | qvarsym | qconsym
                 | literal | special | reservedop | reservedid
literal ::= integertoken | floattoken | chartoken | stringtoken
special ::= '(' | ')' | ',' | ';' | '[' | ']' | '`' | '{' | '}'
private whitespace ::= whitetoken {whitetoken} *
private whitetoken ::= whitechar | comment | ncomment
//newline ::= EOL //("\r" "\n") | "\n" | "\r" | "\f"
//whitechar ::= /*newline |*/ "\v" | ' ' | "\t"
//comment ::= linecomment //dashes {any1} * newline
ncomment ::= opencom anyseq {ncomment anyseq} * closecom
anyseq ::= !( opencom | closecom ) lexeme *
//any ::= graphic | whitechar
//any1 ::= graphic | ' ' | "\t"
//graphic ::= small | large | symbol | digit | special | doublequote | "'"

//small ::= ascSmall | '_'
//large ::= ascLarge
symbol ::= '!' | '#' | '$' | '%' | '&' | '*' | '+' | '.' | '/' | '<' | '=' | '>' | '?' | '@'
         | '\' | '^' | '|' | '-' | '~' | ':'
//digit ::= ascDigit

varid ::= !(reservedid | dashes) varidRegexp
//conid ::= large {small | large | digit | "'" } *

reservedid  ::= 'case' | 'classtoken' | 'data' | 'default' | 'deriving' | 'do' | 'else'
              | 'foreign' | 'if' | 'import' | 'infix' | 'infixl' | 'infixr'
              | 'instance' | 'in' | 'let' | 'module' | 'newtype' | 'of' | 'then' | 'type'
              | 'where' | '_'

varsym ::= !(reservedop whitetoken) ( !':' symbol {symbol} * )
consym ::= !reservedopWithoutCons ( ':' {symbol} *)

reservedopWithoutCons ::= '..' | '::' | '=' | '\' | '|' | '<-' | '->' | '@' | '~' | '=>'
reservedop ::= ':' | reservedopWithoutCons

/* Unused:
tyvar       ::= varid
tycon       ::= conid
tycls       ::= conid
*/
modid       ::= {conid '.'} * conid

qvarid	    ::= [modid '.'] varid
qconid	    ::= [modid '.'] conid
/* Unused:
qtycon	    ::= [modid '.'] tycon
qtycls	    ::= [modid '.'] tycls
*/
qvarsym	    ::= [modid '.'] varsym
qconsym	    ::= [modid '.'] consym

decimal     ::= digit {digit} *
//octal       ::= octit {octit} *
//hexadecimal ::= hexit {hexit} *
integertoken ::= decimal
               | octalLiteral
               | hexadecimalLiteral
floattoken  ::= decimal '.' decimal [exponent]
              | decimal exponent
exponent    ::= exponentPrefix decimal

chartoken   ::= "'" (!("'" | '\') graphic | ' ' | !'\&' escape) "'"
stringtoken ::= doublequote { !(doublequote | '\') graphic | ' ' | escape | gap} * doublequote
escape      ::= charesc | ('\' decimal | octalEscape | hexadecimalEscape /* TODO: | ascii */ )
/* TODO:
ascii ::= ^cntrl | NUL | SOH | STX | ETX | EOT | ENQ | ACK
| BEL | BS | HT | LF | VT | FF | CR | SO | SI | DLE
| DC1 | DC2 | DC3 | DC4 | NAK | SYN | ETB | CAN
| EM | SUB | ESC | FS | GS | RS | US | SP | DEL
cntrl ::= ascLarge | @ | [ | \ | ] | ^ | _
*/
gap         ::= '\' whitechar {whitechar} * '\'
